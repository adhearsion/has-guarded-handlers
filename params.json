{"name":"has-guarded-handlers","body":"### What is it for?\r\nHasGuardedHandlers allows an object's API to provide flexible handler registration, storage and matching to arbitrary events.\r\n\r\n### How do I use it?\r\n\r\n```ruby\r\nrequire 'has_guarded_handlers'\r\n\r\nclass A\r\n  include HasGuardedHandlers\r\nend\r\n\r\na = A.new\r\na.register_handler :event, :type => :foo do |event|\r\n  puts \"Handled the event of type #{event.type} with value #{event.value}\"\r\nend\r\n\r\nEvent = Class.new Struct.new(:type, :value)\r\n\r\na.trigger_handler :event, Event.new(:foo, 'bar')\r\n```\r\n\r\nRegister a handler for a particular named channel:\r\n\r\n```ruby\r\na.register_handler(:event) { ... }\r\n# or\r\na.register_handler(:event, :type => :foo) { ... }\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nRegister a global handler for all channels:\r\n\r\n```ruby\r\na.register_handler { ... }\r\n# or\r\na.register_handler(nil, :type => :foo) { ... }\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nRegister a temporary handler, which is deleted once triggered:\r\n\r\n```ruby\r\na.register_tmp_handler(:event) { ... } # This will only fire once\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nHandlers are triggered in order of priority, followed by order of declaration. By default, all handlers are registered with priority 0, and are thus executed in the order declared:\r\n\r\n```ruby\r\na.register_handler { ... } # This is triggered first\r\na.register_handler { ... } # This is triggered second\r\n...\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nYou may specify a handler priority in order to change this order. Higher priority is executed first:\r\n\r\n```ruby\r\na.register_handler(:event) { ... } # This is triggered second\r\na.register_handler_with_priority(:event, 10) { ... } # This is triggered first\r\n...\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nYou may specify a priority for a temporary handler:\r\n\r\n```ruby\r\na.register_handler_with_options(:event, {:tmp => true, :priority => 10}, :foo => :bar) { ... }\r\n```\r\n\r\n### Handler chaining\r\n\r\nWhen multiple handlers match the event, the return value of each handler will determine if the handler chain continues. A truthy return value will cause the handler to swallow the event and halt the handler chain. A falsy return value will continue the chain.\r\n\r\nIt is possible to explicitly pass to the next handler by throwing `:pass` in your handler:\r\n\r\n```ruby\r\na.register_handler(:event) { throw :pass }\r\na.register_handler(:event) { ... } # This will be executed\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\nor indeed explicitly halt the handler chain by throwing `:halt` in the handler:\r\n\r\n```ruby\r\na.register_handler(:event) { throw :halt }\r\na.register_handler(:event) { ... } # This will not be executed\r\n\r\na.trigger_handler :event, :foo\r\n```\r\n\r\n### What are guards?\r\n\r\nGuards are a concept borrowed from Erlang. They help to better compartmentalise handlers.\r\n\r\nThere are a number of guard types and one bit of special syntax. Guards act like AND statements. Each condition must be met if the handler is to be used.\r\n\r\n```ruby\r\n# Equivalent to saying (event.chat? && event.body)\r\nregister_handler :chat?, :body\r\n```\r\n\r\nThe different types of guards are:\r\n\r\n```ruby\r\n# Class / Module\r\n#   Checks that the event is of the type specified\r\n#   Equivalent to event.is_a? Foo\r\nregister_handler Foo\r\n\r\n# Symbol\r\n#   Checks for a non-false reply to calling the symbol on the event\r\n#   Equivalent to event.chat?\r\nregister_handler :chat?\r\n\r\n# Hash with any value (:body => 'exit')\r\n#   Calls the key on the event and checks for equality\r\n#   Equivalent to event.body == 'exit'\r\nregister_handler :body => 'exit'\r\n\r\n# Hash with regular expression (:body => /exit/)\r\n#   Calls the key on the event and checks for a match\r\n#   Equivalent to event.body.match /exit/\r\nregister_handler :body => /exit/\r\n\r\n# Hash with array value (:name => [:gone, :forbidden])\r\n#   Calls the key on the event and check for inclusion in the array\r\n#   Equivalent to [:gone, :forbidden].include?(event.name)\r\nregister_handler :name => [:gone, :fobidden]\r\n\r\n# Hash with array key ([:[], :name] => :gone)\r\n#   Calls the first element of the key on the event, passing the other elements as arguments\r\n#   and checks the value matches\r\n#   Equivalent to event[:name] == :gone\r\nregister_handler [:[], :name] => :gone\r\n\r\n# Proc\r\n#   Calls the proc passing in the event\r\n#   Checks that the ID is modulo 3\r\nregister_handler proc { |m| m.id % 3 == 0 }\r\n\r\n# Array\r\n#   Use arrays with the previous types effectively turns the guard into\r\n#   an OR statement.\r\n#   Equivalent to event.body == 'foo' || event.body == 'baz'\r\nregister_handler [{:body => 'foo'}, {:body => 'baz'}]\r\n```\r\n\r\n### Authors and Contributors\r\n* @sprsquish\r\n* @benlangfeld","tagline":"Add event handlers to your Ruby objects, and guard them against unnecessary invokation ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}